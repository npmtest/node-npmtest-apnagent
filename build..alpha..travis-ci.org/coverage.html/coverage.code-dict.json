{"/home/travis/build/npmtest/node-npmtest-apnagent/test.js":"/* istanbul instrument in package npmtest_apnagent */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-apnagent/lib.npmtest_apnagent.js":"/* istanbul instrument in package npmtest_apnagent */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_apnagent = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_apnagent = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-apnagent/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-apnagent && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_apnagent */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_apnagent\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_apnagent.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_apnagent.rollup.js'] =\n            local.assetsDict['/assets.npmtest_apnagent.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_apnagent.__dirname + '/lib.npmtest_apnagent.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-apnagent/node_modules/apnagent/index.js":"module.exports = process.env.APNAGENT_COV\n  ? require('./lib-cov/apnagent')\n  : require('./lib/apnagent');\n","/home/travis/build/npmtest/node-npmtest-apnagent/node_modules/apnagent/lib/apnagent.js":"/*!\n * apnagent\n * Copyright(c) 2012-2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * APN Agent version\n */\n\nexports.version = '1.1.3';\n\n/*!\n * Agent (Live)\n */\n\nexports.Agent = require('./apnagent/agent/live');\n\n/*!\n * Agent (Mock)\n */\n\nexports.MockAgent = require('./apnagent/agent/mock');\n\n/*!\n * Feedback (Live)\n */\n\nexports.Feedback = require('./apnagent/feedback/live');\n\n/*!\n * Feedback (Mock)\n */\n\nexports.MockFeedback = require('./apnagent/feedback/mock');\n\n/*!\n * Device\n */\n\nexports.Device = require('./apnagent/device');\n\n/*!\n * Errors\n */\n\nexports.errors = require('./apnagent/errors');\n","/home/travis/build/npmtest/node-npmtest-apnagent/node_modules/apnagent/lib/apnagent/agent/live.js":"/*!\n * apnagent - Agent (Live)\n * Copyright(c) 2012-2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar debug = require('sherlock')('apnagent:agent-live')\n  , inherits = require('tea-inherits')\n  , ms = require('tea-ms')\n  , tls = require('tls');\n\n/*!\n * Internal dependancies\n */\n\nvar Base = require('./base')\n  , errors = require('../errors')\n  , util = require('../util');\n\n/*!\n * Primary Export\n */\n\nmodule.exports = Agent;\n\n/**\n * Agent (Live)\n *\n * The agent keeps a constant connection with\n * the apn service. All messages are pass through\n * its open stream. It will manage reconnections\n * and authentication.\n *\n * See APNS Documentation\n *\n * @api public\n */\n\nfunction Agent () {\n  Base.call(this);\n}\n\n/*!\n * Inherits from Base\n */\n\ninherits(Agent, Base);\n\n/**\n * ._reconnect()\n *\n * Establish the broken connection again\n *\n * @name _reconnect\n * @api private\n */\n\nAgent.prototype._reconnect = function(){\n  var self = this\n    , gwe = self.meta.gatewayError\n    , pos = 0;\n\n  if (gwe && 'undefined' !== typeof gwe.identifier) {\n    debug('(cache) since: %d', gwe.identifier);\n    self.cache.sinceId(gwe.identifier, function (obj, id) {\n      debug('(queue) push: %d', id);\n      self.queue.pushAt(pos++, obj);\n    });\n  }\n\n  debug('(gateway) reconnecting');\n  self.connect(function (err) {\n    if (err) return;\n    debug('(gateway) reconnected');\n    self.emit('gateway:reconnect');\n  });\n};\n\n/**\n * .connect (callback)\n *\n * Begin the server connection sequence and\n * establish all listeners needed for operation,\n * including a callback on successful connection.\n *\n * @param {Function} callback on connect\n * @name connect\n * @api public\n */\nAgent.prototype.connect = function (cb) {\n  cb = cb || function () {};\n\n  var self = this\n    , delay = this.get('reconnect delay')\n    , opts = util.gatewayOptions(this)\n    , recon = this.enabled('reconnect')\n    , ttl = this.get('cache ttl')\n    , gateway;\n\n  // don't try to connect without credentials\n  if (!opts.pfx && !opts.key && !opts.cert) {\n    process.nextTick(function () {\n      var err = new errors.GatewayAuthorizationError('Insufficient credentials');\n      debug('(gateway) error: %s', err.message);\n      self.emit('gateway:error', err);\n      cb(err);\n    });\n\n    return this;\n  }\n\n  // reset state\n  this.meta.gatewayError = null;\n\n  // connect to gateway\n  debug('(gateway) connecting - %s:%d', opts.host, opts.port);\n  gateway = tls.connect(opts, function () {\n    if (gateway.authorized) {\n      debug('(gateway) connected - %s:%d', opts.host, opts.port);\n      self.connected = true;\n      self.cache.ttl = ttl;\n      self.cache.resume();\n      self.queue.resume();\n      self.emit('gateway:connect');\n      cb();\n    } else {\n      var err = new errors.GatewayAuthorizationError(gateway.authorizationError);\n      debug('(gateway) unauthorized - %s:%d', opts.host, opts.port, gateway.authorizationError);\n      self.gateway.destroy();\n      self.emit('gateway:error', err);\n      cb(err);\n    }\n  });\n\n  // handle a disconnection\n  gateway.on('close', function () {\n    self.cache.pause();\n    self.queue.pause();\n    self.gateway = null;\n\n    if (self.connected && recon) {\n      debug('(gateway) disconnected - %s:%d', opts.host, opts.port);\n      self.connected = false;\n      self.meta.timer = setTimeout(self._reconnect.bind(self), ms(delay));\n    } else {\n      debug('(gateway) closed - %s:%d', opts.host, opts.port);\n      self.connected = false;\n      self.emit('gateway:close');\n    }\n  });\n\n  // handle incoming data\n  gateway.on('data', function (buf) {\n    debug('(gateway) data: %d bytes', buf.length);\n    self.decoder.write(buf);\n  });\n\n  // emit errors;\n  gateway.on('error', function (err) {\n    debug('(gateway) error: %s', err.message || 'Unspecified Error');\n    if (self.gateway) self.gateway.destroy();\n    self.emit('gateway:error', err);\n  });\n\n  // mount\n  this.gateway = gateway;\n  return this;\n};\n\n/**\n * .close ()\n *\n * Closes the gateway connection.\n *\n * @name close\n * @api public\n */\n\nAgent.prototype.close = function (cb) {\n  cb = cb || function () {};\n\n  // leave if nothing needs to be done\n  if (!this.connected || !this.gateway) {\n    clearTimeout(this.meta.timer);\n    process.nextTick(cb);\n    return this;\n  }\n\n  var self = this\n    , drain = this.queue.drain;\n\n  // wait for queue to finish processing current\n  this.queue.drain = function () {\n    debug('(gateway) disconnecting');\n    self.cache.pause();\n    self.gateway.once('close', cb);\n    self.gateway.destroy();\n    self.queue.drain = drain;\n  };\n\n  // set things in motion\n  this.connected = false;\n  this.queue.pause();\n  return this;\n};\n\nAgent.prototype._queueIterator = function (obj, next) {\n  var self = this\n    , cache = this.cache\n    , encoder = this.encoder\n    , stream = encoder.stream(obj.codec)\n    , id = obj.json.identifier\n    , queue = this.queue;\n\n  // wait for encoded message\n  encoder.once('readable', function () {\n    var buf = encoder.read()\n      , gateway = self.gateway;\n\n    // requeue if not connected\n    if (!gateway || !gateway.writable || !self.connected) {\n      debug('(queue) pause: not connected');\n      queue.pause();\n      queue.pushAt(0, obj);\n      return next();\n    }\n\n    debug('(gateway) write: %d', id);\n    gateway.write(buf, function () {\n      debug('(cache) push: %d', id);\n      cache.push(id, obj);\n      next();\n    });\n  });\n\n  // encode message\n  debug('(encoder) write: %d', id);\n  stream.write(obj.json);\n};\n","/home/travis/build/npmtest/node-npmtest-apnagent/node_modules/apnagent/lib/apnagent/agent/base.js":"/*!\n * apnagent - Agent (Base)\n * Copyright(c) 2012-2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar debug = require('sherlock')('apnagent:agent-base')\n  , EventEmitter = require('drip').EnhancedEmitter\n  , facet = require('facet')\n  , inherits = require('tea-inherits')\n  , lotus = require('lotus')\n  , Queue = require('breeze-queue')\n\n/*!\n * Internal dependancies\n */\n\nvar Cache = require('../cache')\n  , codecs = require('../codecs')\n  , errors = require('../errors')\n  , Message = require('../message');\n\n/*!\n * Constants\n */\n\n// max unique ids\nvar INT32 = 0xffffffff;\n\n// Apple notification error messages\nvar notifErrors = {\n    0: 'No errors encountered'\n  , 1: 'Processing error'\n  , 2: 'Missing device token'\n  , 3: 'Missing topic'\n  , 4: 'Missing payload'\n  , 5: 'Invalid token size'\n  , 6: 'Invalid topic size'\n  , 7: 'Invalid payload size'\n  , 8: 'Invalid token'\n  , 255: 'None (unknown)'\n};\n\n/*!\n * Primary Export\n */\n\nmodule.exports = Base;\n\n/**\n * ## Agent API\n *\n * This API section covers both the `Agent` and `MockAgent`\n * classes. The architecture was developed to provide\n * feature parity for not just available methods but the\n * events emitted and processing methodology. Any significant\n * differences have already been outlined in the Agent Guide.\n *\n * @header Agent API\n * @see #header-agent Agent Guide\n */\n\nfunction Base () {\n  EventEmitter.call(this, { delimeter: ':' });\n  this.connected = false;\n\n  // default settings\n  this.set('cache ttl', '10m');\n  this.set('codec', 'enhanced');\n  this.set('expires', 0);\n  this.enable('reconnect');\n  this.set('reconnect delay', 3000);\n  this.disable('sandbox');\n\n  // internal storage\n  this.meta = {};\n  this.meta.lastId = -1;\n  this.meta.gatewayError = null;\n  this.meta.timer = null;\n\n  var self = this\n    , cache, decoder, encoder, queue;\n\n  // temp storage for messages\n  cache = new Cache();\n\n  // queue handles writing buffers to gateway\n  queue = new Queue(function () {\n    debug('(queue) iterate');\n    self._queueIterator.apply(self, arguments);\n  }, 1);\n\n  // start in paused state\n  cache.pause();\n  queue.pause();\n\n  // emit queue errors on agent\n  queue.onerror = function (err) {\n    debug('(queue) error: %s', err.message);\n    self.emit('queue:error', err);\n  };\n\n  // emit queue drain on agent\n  queue.drain = function () {\n    debug('(queue) drain');\n    self.emit('queue:drain');\n  };\n\n  // decoder handles incoming apn errors\n  decoder = lotus.createDecoder();\n  decoder.stream(8, codecs.getInterface('gateway response', 'decode'));\n\n  // listen for responses\n  decoder.stream(8).on('readable', function () {\n    var obj = this.read();\n    obj.code = obj.code[0];\n\n    var message = notifErrors[obj.code] || 'None (unknown)'\n      , err = new errors.GatewayMessageError(message, obj)\n      , cached = self.cache.get(obj.identifier)\n      , msg = null;\n\n    if (cached) {\n      msg = new Message(self, 'enhanced', cached.json.payload);\n      msg.device(cached.json.deviceToken);\n      msg.meta.expires = cached.json.expiration;\n    }\n\n    debug('(message) error: %s', err.message);\n    self.meta.gatewayError = err;\n    self.emit('message:error', err, msg);\n  });\n\n  // encoder handles converting msg json to buffers\n  encoder = lotus.createEncoder();\n  encoder.stream(0, codecs.getInterface('gateway simple', 'encode'));\n  encoder.stream(1, codecs.getInterface('gateway enhanced', 'encode'));\n\n  // mount objects\n  this.cache = cache;\n  this.decoder = decoder;\n  this.encoder = encoder;\n  this.gateway = null;\n  this.queue = queue;\n}\n\n/*!\n * Inherits from EnhancedEmitter\n */\n\ninherits(Base, EventEmitter);\n\n/*!\n * Mount facet helpers\n */\n\nfacet(Base.prototype);\n\n/**\n * ### .createMessage ([encoding])\n *\n * Creates a message that can be further modified\n * through chaining. Do not provide arguments unless\n * you know what you are doing.\n *\n * @param {String} encoding (default: utf8)\n * @return {Message} new message\n * @name create\n * @api public\n * @see #agent-messages Agent Guide - Sending Messages\n * @see #header-message_builder_api Message Builder API\n */\n\nBase.prototype.createMessage = function (enc) {\n  var codec = this.get('codec');\n  return new Message(this, codec, { enc: enc });\n};\n\n/*!\n * .nextId ()\n *\n * Increment the `lastId` used and return the new\n * value. This will be called when a message is\n * created with an agent attached.\n *\n * Since apple requires ids to be int32 compatible,\n * if the last id exceeds 4294967296, it will be\n * reset at zero.\n *\n * @return {Number}\n * @api private\n */\n\nBase.prototype.nextId = function () {\n  var i = ++this.meta.lastId;\n\n  if (i > INT32) {\n    i = this.meta.lastId = 0;\n  }\n\n  return i;\n};\n\n/**\n * ### .send (message[, callback])\n *\n * Serialize the message and catch any validation errors\n * that might occur. If validation passes add the message\n * to the send queue. Messages can also be sent by invoking\n * the message instance's `.send()` method.\n *\n * ```js\n * var message = agent.createMessage();\n *\n * message\n *   .device(token)\n *   .alert('Hello Universe');\n *\n * agent.send(message);\n * ```\n *\n * @param {Message} message to send\n * @param {Function} callback to invoke\n * @return {this} for chaining\n * @name send\n * @api public\n * @see #agent-messages Agent Guide - Sending Messages\n * @see #message_builder_api-send Message#send()\n */\n\nBase.prototype.send = function (msg, cb) {\n  cb = cb || function () {};\n\n  var self = this\n    , codecStr = msg.meta.codec\n    , codec = codecs.getId('gateway ' + codecStr)\n    , json;\n\n  // handle error\n  function error (err) {\n    process.nextTick(function () {\n      debug('(message) error: %s', err.message);\n      cb(err);\n      self.emit('message:error', err, msg);\n    });\n  }\n\n  // check for codec\n  if (!~[ 0, 1 ].indexOf(codec)) {\n    error(new errors.SerializationError('Invalid codec: ' + codecStr));\n    return this;\n  }\n\n  // serialize the message\n  try {\n    json = msg.serialize();\n  } catch (ex) {\n    error(ex);\n    return this;\n  }\n\n  // write json to to the queue\n  debug('(queue) push: %d', json.identifier);\n  this.queue.push({ codec: codec, json: json }, cb, true);\n  return this;\n};\n\nBase.prototype._queueIterator = function (buf, next) {\n  throw new Error('Queue iterator not implemented.');\n};\n\n/**\n * ### .connect ([ callback ])\n *\n * Open an active gateway connection. Once the connection\n * is established the outgoing message queue will begin\n * to process items.\n *\n * @param {Function} callback\n * @return {this} for chaining\n * @name connect\n * @api public\n */\n\nBase.prototype.connect = function () {\n  throw new Error('Gateway connect not implemented.');\n};\n\n/**\n * ### .close ([ callback ])\n *\n * Close the active gateway connection or cancel\n * further reconnect attempts. If the queue is currently\n * processing a message it will wait for the current\n * message to finish before closing.\n *\n * Apple recommends that a connection always remains open\n * even when there are no messages to process. Production\n * deployments should use this sparingly.\n *\n * @param {Function} callback\n * @return {this} for chaining\n * @name close\n * @api public\n */\n\nBase.prototype.close = function () {\n  throw new Error('Gateway close not implemented');\n};\n","/home/travis/build/npmtest/node-npmtest-apnagent/node_modules/apnagent/lib/apnagent/cache.js":"/*!\n * apnagent - Cache\n * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar debug = require('sherlock')('apnagent:cache')\n  , ms = require('tea-ms');\n\n/*!\n * Primary Export\n */\n\nmodule.exports = Cache;\n\n/**\n * Cache\n *\n * A constructed cache is used to keep track of what messages\n * have been sent out and in what order. This is required as\n * Apple will disconnect and not attempt to parse any messages\n * after one has failed.\n *\n * Furthermore, this cache employs a ttl mechanism to conserve\n * memory. Items older than a specific age (default: 10 mins)\n * will be assumed successfully sent and removed from the cache.\n *\n * @param {String|Number} time to live (default: 10 mins)\n * @api public\n */\n\nfunction Cache (ttl) {\n  this.store = [];\n  this.timer = null;\n  this.ttl = ttl || '10m';\n}\n\n/**\n * .length\n *\n * Property which allows quick access to the length of\n * the internal storage. Probably only useful during\n * tests.\n *\n * @return {Number} count of items in the storage\n * @api public\n */\n\nObject.defineProperty(Cache.prototype, 'length', {\n  get: function () {\n    return this.store.length;\n  }\n});\n\n/**\n * .push (id, object[, age])\n *\n * Add an item to the cache. The `id` can be any arbitrary\n * string or number, provided it is unique relative to\n * the items in the cache. The `object` can be of any data\n * type. The `age` should be a number specifing the ms since\n * epoch. It is used internally by the ttl cleaner to ensure\n * items in the index retain their age when flushing since\n * a time. It is also used by the tests to construct scenarios.\n *\n * @param {String|Number} id unique\n * @param {Mixed} object to store\n * @param {Number} timestamp of object creation\n * @return {this} for chaining\n * @api public\n */\n\nCache.prototype.push = function (id, obj, age) {\n  debug('(store) push: %s', id + '');\n  this.store.push({\n      age: age || new Date().getTime()\n    , id: id\n    , obj: obj\n  });\n\n  return this;\n};\n\n/**\n * .get (id)\n *\n * Get the object stored at a specific `id`. This method\n * does not modify the cache. If more than one object\n * has the same id, the first match will be returned.\n *\n * @param {String|Number} id unique\n * @return {Mixed} object at id\n * @api public\n */\n\nCache.prototype.get = function (id) {\n  var i = 0\n    , res = undefined\n    , store = this.store;\n\n  for (; i < store.length; i++){\n    if (store[i].id === id) {\n      res = store[i].obj;\n      break;\n    }\n  }\n\n  return res;\n};\n\n/**\n * .flush ()\n *\n * Remove all items from the internal storage.\n *\n * @return {this} for chaining\n * @api public\n */\n\nCache.prototype.flush = function () {\n  debug('(store) flush');\n  this.store = [];\n  return this;\n};\n\n/**\n * .sinceId (id, iterator)\n *\n * Invoke an iterator on all entries in the cache\n * that were added since a specific id. The object\n * with the matching id will not be included in iteration.\n *\n * Warning: Using this method will flush the cache prior\n * to iteration.\n *\n * Iterator can accept up to three parameters:\n * - `object` - the entry's object\n * - `id` - the entry's id\n * - `age` - the entry's creation timestamp\n *\n * @param {String|Number} id unique\n * @param {Function} iterator\n * @return {this} for chaining\n * @api public\n */\n\nCache.prototype.sinceId = function (id, iterator) {\n  var pos = -1\n    , store = this.store\n    , i = 0\n    , l;\n\n  this.flush();\n\n  // find where to start\n  for (; i < store.length; i++) {\n    if (store[i].id === id) {\n      pos = i;\n      break;\n    }\n  }\n\n  // iterate with the rest\n  if (pos !== -1) {\n    pos++; // we don't want the match\n    for (; pos < store.length; pos++) {\n      l = store[pos];\n      iterator(l.obj, l.id, l.age);\n    }\n  }\n\n  return this;\n};\n\n/**\n * .sinceTime (id, iterator)\n *\n * Invoke an iterator on all entries in the cache\n * that were added after a specific timestamp. Iteration\n * will respect the original ordering, however if an entry\n * does not match the criteria, it will be skipped.\n *\n * Warning: Using this method will flush the cache prior\n * to iteration.\n *\n * Iterator can accept up to three parameters:\n * - `object` - the entry's object\n * - `id` - the entry's id\n * - `age` - the entry's creation timestamp\n *\n * @param {String|Number} id unique\n * @param {Function} iterator\n * @return {this} for chaining\n * @api public\n */\n\nCache.prototype.sinceTime = function (age, iterator) {\n  var store = this.store\n    , i = 0\n    , l;\n\n  this.flush();\n\n  // iterate for all that match\n  for (; i < store.length; i++) {\n    l = store[i];\n    if (l.age > age) {\n      iterator(l.obj, l.id, l.age);\n    }\n  }\n\n  return this;\n};\n\n/**\n * .resume ()\n *\n * Resume the TTL-based cleaning timer. An initial clean\n * will be performed upon the initial invocation of this\n * method.\n *\n * @return {this} for chaining\n * @ap public\n */\n\nCache.prototype.resume = function () {\n  var self = this\n    , ttl = ms(this.ttl);\n\n  // re-add new objects\n  function push (obj, id, age) {\n    self.push(id, obj, age);\n  }\n\n  // get older than and iterate\n  function clean () {\n    debug('(timer) clean older than %dms', ttl);\n    self.sinceTime(new Date().getTime() - ttl, push);\n    self.timer = setTimeout(clean, ttl);\n  }\n\n  // do first cleaning\n  debug('(timer) resume');\n  clean();\n  return this;\n};\n\n/**\n * .pause ()\n *\n * Pause the TTL-based cleaning timer.\n *\n * @return {this} for chaining\n * @ap public\n */\n\nCache.prototype.pause = function () {\n  debug('(timer) pause')\n  clearTimeout(this.timer);\n  return this;\n};\n","/home/travis/build/npmtest/node-npmtest-apnagent/node_modules/apnagent/lib/apnagent/codecs/index.js":"/*!\n * apnagent - Codecs\n * Copyright(c) 2012-2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Codec Storage\n */\n\nvar codecs = [];\n\n/**\n * Get one of the interfaces from a selected\n * codec. For example...\n *\n * ```js\n * writer.use(0, exports.getInterface('gateway simple', 'writer'));\n * ```\n *\n * @param {String} codec name\n * @param {String} codec interface\n * @return {Object} lotus reader/writer\n * @api public\n */\n\nexports.getInterface = function (name, interface) {\n  var codec = codecs.filter(function (codec) {\n    return name === codec.name;\n  })[0];\n\n  return codec\n    ? codec.mod[interface]\n    : undefined;\n};\n\n/**\n * Get the id to use when writing to a lotus\n * stream.\n *\n * ```js\n * writer.write(exports.getID('gateway simple'), json);\n * ```\n *\n * @param {String} codec name\n * @return {Number} id\n * @api public\n */\n\nexports.getId = function (name) {\n  var codec = codecs.filter(function (codec) {\n    return name === codec.name;\n  })[0];\n\n  return codec\n    ? codec.id\n    : undefined;\n};\n\n/*!\n * Push `simple` gateway codec\n */\n\ncodecs.push({\n    name: 'gateway simple'\n  , id: 0\n  , mod: require('./gateway.simple')\n});\n\n/*!\n * Push `enhanced` gateway codec\n */\n\ncodecs.push({\n    name: 'gateway enhanced'\n  , id: 1\n  , mod: require('./gateway.enhanced')\n});\n\n/*!\n * Push `response` gateway codec\n */\n\ncodecs.push({\n    name: 'gateway response'\n  , id: 8\n  , mod: require('./gateway.response')\n});\n\n/*!\n * Push `response` feedback codec\n */\n\ncodecs.push({\n    name: 'feedback response'\n  , id: -1\n  , mod: require('./feedback.response')\n});\n","/home/travis/build/npmtest/node-npmtest-apnagent/node_modules/apnagent/lib/apnagent/codecs/gateway.simple.js":"/*!\n * apnagent - Simple Codec\n * Copyright(c) 2012-2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar lotus = require('lotus');\n\n/**\n * .decode\n *\n * Simple Apple Push Notifications protocol.\n * See APN documents for the specification.\n *\n * @api public\n */\n\nexports.decode = lotus.decode()\n  .u16be('tokenLen')\n  .take('tokenLen', 'deviceToken')\n  .u16be('payloadLen')\n  .take('payloadLen', 'payload', JSON.parse);\n\n/**\n * .encode\n *\n * Enhanced Apple Push Notifications protocol.\n * See APN documents for the specifications.\n *\n * @api public\n */\n\nexports.encode = lotus.encode()\n  .u16be(function (msg) {\n    return msg.deviceToken.length;\n  })\n  .push('deviceToken')\n  .u16be(function (msg) {\n    var payload = JSON.stringify(msg.payload);\n    return Buffer.byteLength(payload, 'utf8');\n  })\n  .write('payload', 'utf8', JSON.stringify);\n","/home/travis/build/npmtest/node-npmtest-apnagent/node_modules/apnagent/lib/apnagent/codecs/gateway.enhanced.js":"/*!\n * apnagent - Enhanced Codec\n * Copyright(c) 2012-2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar lotus = require('lotus');\n\n/**\n * .decode\n *\n * Enhanced Apple Push Notifications protocol.\n * See APN documents for the specification.\n *\n * @api public\n */\n\nexports.decode = lotus.decode()\n  .u32be('identifier')\n  .u32be('expiration')\n  .u16be('tokenLen')\n  .take('tokenLen', 'deviceToken')\n  .u16be('payloadLen')\n  .take('payloadLen', 'payload', JSON.parse);\n\n/**\n * .encode\n *\n * Enhanced Apple Push Notifications protocol.\n * See APN documents for the specifications.\n *\n * @api public\n */\n\nexports.encode = lotus.encode()\n  .u32be('identifier')\n  .u32be('expiration')\n  .u16be(function (msg) {\n    return msg.deviceToken.length;\n  })\n  .push('deviceToken')\n  .u16be(function (msg) {\n    var payload = JSON.stringify(msg.payload);\n    return Buffer.byteLength(payload, 'utf8');\n  })\n  .write('payload', 'utf8', JSON.stringify);\n","/home/travis/build/npmtest/node-npmtest-apnagent/node_modules/apnagent/lib/apnagent/codecs/gateway.response.js":"/*!\n * apnagent - Response Codec\n * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar lotus = require('lotus');\n\n/**\n * .decode\n *\n * Response Apple Push Notifications protocol.\n * See APN documents for the specification.\n *\n * @api public\n */\n\nexports.decode = lotus.decode()\n  .take(1, 'code')\n  .u32be('identifier');\n","/home/travis/build/npmtest/node-npmtest-apnagent/node_modules/apnagent/lib/apnagent/codecs/feedback.response.js":"/*!\n * apnagent - Response Codec\n * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar lotus = require('lotus');\n\n/**\n * .decode\n *\n * Response Apple Push Feedback protocol.\n * See APN documents for the specification.\n *\n * @api public\n */\n\nexports.decode = lotus.decode()\n  .u32be('timestamp')\n  .u16be('tokenLen')\n  .take('tokenLen', 'deviceToken');\n\n/**\n * .encode\n *\n * Response Apple Push Feedback protocol.\n * See APN documents for the specifications.\n *\n * @api public\n */\n\nexports.encode = lotus.encode()\n  .u32be('timestamp')\n  .u16be(function (msg) {\n    return msg.deviceToken.length;\n  })\n  .push('deviceToken');\n","/home/travis/build/npmtest/node-npmtest-apnagent/node_modules/apnagent/lib/apnagent/errors.js":"/*!\n * apnagent - Errors\n * Copyright(c) 2012-2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar error = require('tea-error');\n\n/*!\n * Errors Collection\n */\n\nvar errs = [\n    'FeedbackAuthorizationError'\n  , 'GatewayAuthorizationError'\n  , 'GatewayMessageError'\n  , 'MessageSerializationError'\n];\n\n/*!\n * Mount to exports\n */\n\nerrs.forEach(function (err) {\n  exports[err] = error(err);\n});\n","/home/travis/build/npmtest/node-npmtest-apnagent/node_modules/apnagent/lib/apnagent/message.js":"/*!\n * apnagent - Message Builder\n * Copyright(c) 2012-2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar extend = require('tea-extend')\n  , ms = require('tea-ms');\n\n/*!\n * Internal dependencies\n */\n\nvar Device = require('./device')\n  , errors = require('./errors')\n  , util = require('./util');\n\n/*!\n * Primary export\n */\n\nmodule.exports = Message;\n\nvar MAX_PAYLOAD_SIZE = 2048;\n\n/**\n * ## Message Builder API\n *\n * A message encapsulates all data points that will\n * be encoded and sent through the wire to APNS. The message\n * builder is a chainable API that provides full feature\n * coverage of the Apple Push Notification specifications.\n *\n * The preferred method of composing messages is directly\n * from a constructed `Agent` or `MockAgent`.\n *\n * ```js\n * var msg = agent.createMessage();\n * ```\n *\n * @header Message Builder API\n */\n\nfunction Message (agent, codec, opts) {\n  /*!\n   * @param {Agent} agent to use for sending\n   * @param {String} default codec\n   * @param {Object} payload to import\n   * @api public\n   */\n\n  this._agent = agent;\n  this.encoding = 'utf8';\n\n  this.meta = {};\n  this.meta.codec = codec;\n  this.meta.device = new Device();\n  this.meta.expires = null;\n\n  this.settings = {};\n  this.payload = {};\n  this.aps = {};\n\n  opts = opts || {};\n\n  // import custom encoding\n  if (opts.enc) this.encoding = opts.enc;\n\n  // import custom variables\n  for (var name in opts) {\n    if (name === 'aps' || name === 'enc') continue;\n    this.set(name, opts[name]);\n  }\n\n  if (opts.aps) {\n    // import badge/sound\n    if (opts.aps.badge) this.badge(opts.aps.badge);\n    if (opts.aps.sound) this.sound(opts.aps.sound);\n    if (opts.aps['content-available']) this.contentAvailable(opts.aps['content-available']);\n\n    // import alert\n    if (opts.aps.alert && 'string' === typeof opts.aps.alert) {\n      this.alert('body', opts.aps.alert);\n    } else if (opts.aps.alert) {\n      this.alert(opts.aps.alert);\n    }\n  }\n\n  if (agent && 'simple' !== codec) {\n    this.expires(agent.get('expires'));\n  }\n}\n\n/**\n * ### .alert (key, value)\n *\n * Sets variables to be included in the `alert` dictionary\n * for the `aps` portion of the payload. If you wish to set\n * a singlular message, set the `body` key. You may also set\n * any of the other values outlined in the APNS documentation\n * and the codecs will optimize the payload format for delivery.\n *\n * ##### Allowed keys:\n *\n * - `body`\n * - `action-loc-key`\n * - `loc-key`\n * - `loc-args`\n * - `launch-image`\n *\n * ```js\n * // just set body\n * msg.alert('Hello Universe');\n *\n * // set multiple values\n * msg.alert({\n *     body: 'Hello Universe'\n *   , 'launch-image': 'notif.png'\n * });\n *\n * // chainable\n * msg\n *   .alert('Hello Universe')\n *   .alert('launch-image', 'notif.png');\n * ```\n *\n * @param {String|Object} alert body, string key or object of alert settings\n * @param {Mixed} value (when first argument is a string)\n * @returns {this} for chaining\n * @api public\n * @name alert\n */\n\nMessage.prototype.alert = function (key, value) {\n  var allowed = [\n      'body'\n    , 'action-loc-key'\n    , 'loc-key'\n    , 'loc-args'\n    , 'launch-image'\n  ];\n\n  if ('object' === typeof key) {\n    for (var name in key) {\n      this.alert(name, key[name]);\n    }\n  } else if (arguments.length === 1) {\n    this.aps['body'] = key;\n  } else {\n    if (!~allowed.indexOf(key)) return this;\n    this.aps[key] = value;\n  }\n\n  return this;\n};\n\n/**\n * ### .set (key, value)\n *\n * Set extra key values that will be incuded\n * as part of the payload. `aps` is reserved by\n * Apple and `enc` is reserved by apnagent.\n *\n * Is a key/value you pair is provided it will\n * be set. If an object is provided, all data points\n * will be merged into the current payload.\n *\n * ```js\n * // single value\n * msg.set('key', 'value');\n *\n * // multiple values\n * msg.set({\n *     key1: 'value1'\n *   , key2: 'value2'\n * });\n *\n * // or chainable\n * msg\n *   .set('key1', 'value1')\n *   .set('key2', 'value2');\n * ```\n *\n * @param {String|Object} string key or object of custom settings\n * @param {Mixed} value (when first argument is string)\n * @returns {this} for chaining\n * @api public\n * @name set\n */\n\nMessage.prototype.set = function (key, value) {\n  if ('object' === typeof key) {\n    for (var name in key) {\n      this.set(name, key[name]);\n    }\n  } else {\n    if (key === 'aps') return;\n    this.payload[key] = value;\n  }\n\n  return this;\n};\n\n/**\n * ### .device (token)\n *\n * Set the device that this message is to be delivered\n * to. Device can be provided as a string or buffer. If\n * provided as a string, it will be sanitized of spaces\n * and extra characters (such as `<` and `>`).\n *\n * ```js\n * msg.device('a1b2c3');\n * msg.device('<a1b2c3>');\n * ```\n *\n * @param {apnagent.Device|String|Buffer} device token\n * @returns {this} for chaining\n * @api public\n * @name device\n */\n\nMessage.prototype.device = function (device) {\n  if (!arguments.length) {\n    return this.meta.device;\n  } else if (device instanceof Device) {\n    this.meta.device = device;\n  } else {\n    this.meta.device.token = device;\n  }\n\n  return this;\n};\n\n/**\n * ### .expires (time)\n *\n * Set the message expiration date when being used\n * with the enhanced codec. The default value is `0` which\n * will indicate to Apple to only attempt to deliver\n * the message once.\n *\n * Should be provided as the number of ms until expiration\n * or as a string that can be converted, such as `1d`.\n *\n * ```js\n * // set to specific time in future\n * msg.expires('30m'); // 30 minutes\n * msg.expires('1d'); // 1 day\n *\n * // reset to default value\n * msg.expires(0);\n * msg.expires(true);\n * ```\n *\n * @param {Number|String} time until expiration\n * @returns {this} for chaining\n * @api public\n * @name expires\n */\n\nMessage.prototype.expires = function (time) {\n  if ('number' === typeof time) {\n    this.meta.expires = time === 0 ? time : ms.unix(time);\n    this.meta.codec = 'enhanced';\n  } else if (true === time) {\n    this.meta.expires = 0;\n    this.meta.codec = 'enhanced';\n  } else if (!time) {\n    this.meta.expires = null;\n    this.meta.codec = 'simple'\n  } else {\n    this.meta.expires = ms.unix(time);\n    this.meta.codec = 'enhanced';\n  }\n\n  return this;\n};\n\n/**\n * ### .badge (number)\n *\n * Set the badge number to be displayed.\n *\n * ```js\n * msg.badge(4);\n * ```\n *\n * @param {Number} badge count\n * @returns {this} for chaining\n * @api public\n * @name badge\n */\n\nMessage.prototype.badge = function (n) {\n  this.settings.badge = n;\n  return this;\n};\n\n/**\n * ### .sound (file)\n *\n * Set the sound file to be played when this message\n * is delivered if the app is closed.\n *\n * ```js\n * msg.sound('bingbong.aiff');\n * ```\n *\n * @param {String} sound file\n * @returns {this} for chaining\n * @api public\n * @name sound\n */\n\nMessage.prototype.sound = function (sound) {\n  this.settings.sound = sound;\n  return this;\n};\n\n\n/**\n * ### .contentAvailable (bool)\n *\n * Set the content-available flag for content download\n * push notifications\n *\n * ```js\n * msg.contentAvailable(true);\n * ```\n *\n * @param {Bool} sets content-available flag to 1 if true\n * @returns {this} for chaining\n * @api public\n * @name contentAvailable\n */\n\nMessage.prototype.contentAvailable = function (contentAvailable) {\n  if (contentAvailable) {\n    this.settings['content-available'] = 1;\n  } else {\n    this.settings['content-available'] = undefined;\n  }\n  return this;\n};\n\n\n/*!\n * .serialize ()\n *\n * Export this message to JSON in a format\n * that will be accepted by Apple as a compatible\n * payload.\n *\n * Used by the codecs.\n *\n * @returns {Object} JSON payload\n * @api public\n */\n\nMessage.prototype.serialize = function () {\n  var codec = this.meta.codec\n    , enc = this.encoding\n    , payload = {}\n    , SE = errors.MessageSerializationError\n    , ssf = arguments.callee;\n\n  // check for device\n  if (!this.meta.device.toBuffer()) {\n    throw new SE('Message device not specified.', null, ssf);\n  }\n\n  // enhanced codec requires expiration\n  if ('enhanced' === codec && null === this.meta.expires) {\n    throw new SE('Message expiration not specified for enhanced codec delivery.', null, ssf);\n  }\n\n  // enchanced code requires agent to generate an id\n  if ('enhanced' === codec && !this._agent) {\n    throw new SE('Message agent not specified for enhanced codec delivery.', null, ssf);\n  }\n\n  // copy over extra variables\n  extend(payload, this.payload);\n\n  // set encoding if not utf8\n  if (enc !== 'utf8') {\n    payload.enc = this.encoding;\n  }\n\n  // copy over badge and sound settings\n  payload.aps = {};\n  extend(payload.aps, this.settings);\n\n  // copy over alert settings\n  var apsLength = Object.keys(this.aps).length;\n  if (apsLength === 1 && this.aps.body) {\n    payload.aps.alert = this.aps.body;\n  } else if (apsLength > 0) {\n    payload.aps.alert = {};\n    extend(payload.aps.alert, this.aps);\n  }\n\n  // check to ensure body is not to long, shorten if possible\n  var str = JSON.stringify(payload)\n    , len = Buffer.byteLength(str, enc);\n\n  if (len > MAX_PAYLOAD_SIZE && this.aps.body) {\n    var over = len - MAX_PAYLOAD_SIZE\n      , bodyLen = Buffer.byteLength(this.aps.body, enc)\n      , body = bodyLen <= over\n        ? null\n        : util.trim(this.aps.body, bodyLen - over);\n\n    if (!body) {\n      throw new SE('Message too long.', null, ssf);\n    }\n\n    if ('string' === typeof payload.aps.alert) {\n      payload.aps.alert = body;\n    } else {\n      payload.aps.alert.body = body;\n    }\n  } else if (len > MAX_PAYLOAD_SIZE) {\n    throw new SE('Message too long.', null, ssf);\n  }\n\n  // construct the response\n  var res = {};\n  res.deviceToken = this.meta.device.toBuffer();\n  res.expiration = this.meta.expires\n  res.identifier = this._agent\n    ? this._agent.nextId()\n    : null;\n  res.payload = payload;\n  return res;\n};\n\n/**\n * ### .send (cb)\n *\n * Send the message through the connected agent. The `cb`\n * function will be invoked with an error if there is\n * a problem serializing the message for transport.\n *\n * If there are no serialization errors, the callback\n * will be invoked when the message has been flushed\n * through the socket. This does NOT mean the message\n * has be received by the device or that Apple has\n * accepted the message. If Apple has a problem with\n * the message it will be emitted on the agent's\n * `message:error` event.\n *\n * ```js\n * msg.send(function (err) {\n *   if (err) {\n *     // handle it\n *   }\n * });\n * ```\n *\n * @param {Function} callback\n * @api public\n * @name send\n */\n\nMessage.prototype.send = function (cb) {\n  cb = cb || function () {};\n  if (!this._agent) return cb(new Error('Agent not associated with message.'));\n  this._agent.send(this, cb);\n};\n","/home/travis/build/npmtest/node-npmtest-apnagent/node_modules/apnagent/lib/apnagent/device.js":"/*!\n * apnagent - Device\n * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Primary export\n */\n\nmodule.exports = Device;\n\n/**\n * ## Device API\n *\n * A small constructor to easily encapsulate a device\n * token so it can be passed around and converted to\n * whatever type is needed for given scenario.\n *\n * If a Device is constructed without parameters, a\n * token can be assigned later by setting the `.token`\n * property to either a string or buffer.\n *\n * The most common usage for the `Device` constructor\n * is to sanitize a device token for storage in a database.\n *\n * ```js\n * var Device = require('apnagent').Device\n *   , device = new Device('<a1b56d2c 08f621d8 7060da2b>');\n * ```\n *\n * @header Device API\n */\n\nfunction Device (token) {\n  /*!\n   * @param {String|Buffer|Device} device token\n   * @api public\n   */\n  if (token instanceof Device) {\n    token = token.toString();\n  }\n\n  this.token = token || undefined;\n}\n\n/**\n * ### .toBuffer ()\n *\n * Convert the stored device token to a buffer.\n *\n * ```js\n * var buf = device.toBuffer();\n * ```\n *\n * @return {Buffer}\n * @api public\n * @name toBuffer\n */\n\nDevice.prototype.toBuffer = function () {\n  return bufferize(this.token);\n};\n\n/**\n * ### .toString ()\n *\n * Convert the stored device token to a string.\n * The string will be sanitized and thus not include\n * spaces or extra characters.\n *\n * ```js\n * var str = device.toString();\n * ```\n *\n * @return {String}\n * @api public\n * @name toString\n */\n\nDevice.prototype.toString = function () {\n  return stringify(this.token);\n};\n\n/**\n * ### .equal (device)\n *\n * Compare the stored device token to another\n * device, string, or buffer. Will also return false\n * if both Devices do not have tokens associated with\n * them.\n *\n * ```js\n * // testing string\n * device.equal('a1b56d2c08f621d87060da2b').should.be.true;\n *\n * // testing another device\n * var dev2 = new Device('feedface');\n * device.equal(dev2).should.be.false;\n * ```\n *\n * @param {Mixed} instance of Device, String, or Buffer\n * @return {Boolean} device tokens equal\n * @api public\n * @name equal\n */\n\nDevice.prototype.equal = function (dev) {\n  var token1 = this.toString()\n    , token2 = dev instanceof Device\n      ? dev.toString()\n      : stringify(dev);\n\n  return token1\n    && token2\n    && token1 === token2;\n};\n\n/*!\n * Turn a device token into its buffer representation.\n * If a Buffer is passed in, it will be converted to\n * a string first so that it is dereferrenced.\n *\n * @param {Mixed} device token\n * @return {Buffer}\n * @api private\n */\n\nfunction bufferize (token) {\n  if (!token) return undefined;\n  if (token instanceof Buffer) token = stringify(token);\n  return new Buffer(token.replace(/[^a-z0-9]/gi, ''), 'hex');\n}\n\n/*!\n * Turn a device token into it's string representation.\n * If a string is passed in, it will be converted to\n * a Buffer first to ensure it is a valid hex.\n *\n * @param {Mixed} device token\n * @return {Buffer}\n * @api private\n */\n\nfunction stringify (token) {\n  if (!token) return undefined;\n  if ('string' === typeof token) token = bufferize(token);\n  return token.toString('hex');\n}\n","/home/travis/build/npmtest/node-npmtest-apnagent/node_modules/apnagent/lib/apnagent/util.js":"/*!\n * apnagent - util\n * Copyright(c) 2012-2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Module Dependencies\n */\n\nvar fs = require('fs');\n\n/*!\n * APN Service Constants\n */\n\nvar APNS_PORT = 2195\n  , APNS_PROD = 'gateway.push.apple.com'\n  , APNS_SANDBOX = 'gateway.sandbox.push.apple.com'\n  , FEED_PORT = 2196\n  , FEED_PROD = 'feedback.push.apple.com'\n  , FEED_SANDBOX = 'feedback.sandbox.push.apple.com';\n\n/**\n * Trim a string to a specific bytes length. It is\n * expected that the string bytes is longer than len.\n *\n * @param {String} string to trim\n * @param {Number} number of bytes to include.\n * @return {String}\n * @api public\n */\n\nexports.trim = function (str, len) {\n  var origLen = Buffer.byteLength(str)\n    , expLen = len - 3\n    , words = str.split(' ')\n    , res = words.shift();\n\n  while (Buffer.byteLength(res + words[0]) < expLen - 2) {\n    res += ' ' + words.shift();\n  }\n  return res + '...';\n};\n\nexports.gatewayOptions = function (agent) {\n  var opts = {};\n\n  // get the tls host based on sandbox\n  opts.host = agent.enabled('sandbox')\n    ? APNS_SANDBOX\n    : APNS_PROD;\n\n  // use default port\n  opts.port = APNS_PORT;\n\n  // pull in tls options\n  exports.tlsOptions(agent, opts);\n\n  return opts;\n};\n\nexports.feedbackOptions = function (agent) {\n  var opts = {};\n\n  // get the tls host based on sandbox\n  opts.host = agent.enabled('sandbox')\n    ? FEED_SANDBOX\n    : FEED_PROD;\n\n  // use default port\n  opts.port = FEED_PORT;\n\n  // pull in tls options\n  exports.tlsOptions(agent, opts);\n\n  return opts;\n};\n\nexports.tlsOptions = function (agent, opts) {\n  opts = opts || {};\n\n  function copy (key) {\n    if (agent.get(key)) opts[key] = agent.get(key);\n  }\n\n  function read (file) {\n    if (!fs.existsSync(file)) return null;\n    return fs.readFileSync(file);\n  }\n\n  // get our tls certificates\n  if (agent.get('pfx') || agent.get('pfx file')) {\n    opts.pfx = agent.get('pfx file')\n      ? read(agent.get('pfx file'))\n      : agent.get('pfx');\n  } else {\n    opts.key = agent.get('key file')\n      ? read(agent.get('key file'))\n      : agent.get('key');\n    opts.cert = agent.get('cert file')\n      ? read(agent.get('cert file'))\n      : agent.get('cert');\n  }\n\n  // apply ca certificate\n  if (agent.get('ca')) {\n    copy('ca');\n    opts.ca = [ opts.ca ];\n  }\n\n  // include passphrase\n  copy('passphrase');\n\n  return opts;\n};\n","/home/travis/build/npmtest/node-npmtest-apnagent/node_modules/apnagent/lib/apnagent/agent/mock.js":"/*!\n * apnagent - Agent (Mock)\n * Copyright(c) 2012-2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar debug = require('sherlock')('apnagent:agent-mock')\n  , inherits = require('tea-inherits')\n  , ms = require('tea-ms')\n  , lotus = require('lotus');\n\n/*!\n * Internal dependancies\n */\n\nvar Base = require('./base')\n  , codecs = require('../codecs')\n  , errors = require('../errors')\n  , util = require('../util')\n  , Device = require('../device');\n\n/*!\n * Primary Export\n */\n\nmodule.exports = Mock;\n\n/**\n * Mock (Mock)\n *\n * The agent keeps a constant connection with\n * the apn service. All messages are pass through\n * its open stream. It will manage reconnections\n * and authentication.\n *\n * See APNS Documentation\n *\n * @api public\n */\n\nfunction Mock () {\n  Base.call(this);\n\n  // Messages sent to these devices will be rejected with error 8 BAD_TOKEN\n  this.badDevices = []\n}\n\n/*!\n * Inherits from Base\n */\n\ninherits(Mock, Base);\n\n/**\n * .connect (callback)\n *\n * Begin the serer connection sequence and\n * establish all listeners needed for operation,\n * including a callback on successful connection.\n *\n * @param {Function} callback on connect\n * @name connect\n * @api public\n */\n\nMock.prototype.connect = function (cb) {\n  cb = cb || function () {};\n\n  var self = this\n    , delay = this.get('reconnect delay')\n    , opts = util.gatewayOptions(this)\n    , recon = this.enabled('reconnect')\n    , ttl = this.get('cache ttl')\n    , gateway;\n\n  // how to perform a reconnect\n  function reconnect () {\n    var gwe = self.meta.gatewayError\n      , pos = 0;\n\n    if (gwe && 'undefined' !== typeof gwe.identifier) {\n      debug('(cache) since: %d', gwe.identifier);\n      self.cache.sinceId(gwe.identifier, function (obj, id) {\n        debug('(queue) push: %d', id);\n        self.queue.pushAt(pos++, obj);\n      });\n    }\n\n    debug('(gateway) reconnecting');\n    self.connect(function (err) {\n      if (err) return;\n      debug('(gateway) reconnected');\n      self.emit('gateway:reconnect');\n    });\n  }\n\n  // reset state\n  this.meta.gatewayError = null;\n\n  // mock gateway parses the outgoing buffers back to json\n  gateway = lotus.createDecoder();\n  gateway.stream(0, codecs.getInterface('gateway simple', 'decode'));\n  gateway.stream(1, codecs.getInterface('gateway enhanced', 'decode'));\n\n  // simulate async connect\n  debug('(gateway) connecting - mock');\n  process.nextTick(function () {\n    debug('(gateway) connected - mock');\n    self.connected = true;\n    self.cache.ttl = ttl;\n    self.cache.resume();\n    self.queue.resume();\n    self.emit('gateway:connect');\n    cb();\n  });\n\n  function shouldBeRejected (msgJson) {\n    msgDevice = new Device(msgJson.deviceToken);\n    reject = false;\n    for (var i = 0; i < self.badDevices.length; i++) {\n      reject = self.badDevices[i].equal(msgDevice)\n    }\n    return reject;\n  }\n\n  // data event is emitted for each message\n  function emitter () {\n    var json = this.read();\n    if (!json) return;\n\n    // Simulate message error at Apple side\n    if (shouldBeRejected(json)) {\n      var err = new errors.GatewayMessageError(\"Invalid token\", {code: 8})\n      self.meta.gatewayError = err;\n\n      debug('(gateway) incoming message error', err.toJSON(false));\n      self.emit('message:error', err, json);\n      gateway.end();\n    } else {\n      debug('(gateway) incoming message', json);\n      self.emit('mock:message', json);\n    }\n  }\n\n  gateway.stream(0).on('readable', emitter);\n  gateway.stream(1).on('readable', emitter);\n\n  // an error is emitted when an incoming message is badly formatted\n  gateway.on('error', function (err) {\n    debug('(gateway) error: %s', err.message || 'Unspecified Error');\n    self.emit('gateway:error', err);\n  });\n\n  // this is similiar to a socket `close` event\n  gateway.on('close', function () {\n    self.cache.pause();\n    self.queue.pause();\n    self.gateway = null;\n\n    if (self.connected && recon) {\n      debug('(gateway) disconnected - mock');\n      self.connected = false;\n      self.meta.timer = setTimeout(reconnect, ms(delay));\n    } else {\n      debug('(gateway) closed - mock');\n      self.connected = false;\n      self.emit('gateway:close');\n    }\n  });\n\n  // mount\n  this.gateway = gateway;\n  return this;\n};\n\n/**\n * .close ()\n *\n * Closes the gateway connection.\n *\n * @name close\n * @api public\n */\n\nMock.prototype.close = function (cb) {\n  cb = cb || function () {};\n\n  // leave if nothing needs to be done\n  if (!this.connected || !this.gateway) {\n    clearTimeout(this.meta.timer);\n    process.nextTick(cb);\n    return this;\n  }\n\n  var self = this\n    , drain = this.queue.drain;\n\n  // wait for queue to finish processing current\n  this.queue.drain = function () {\n    debug('(gateway) disconnecting');\n    self.cache.pause();\n    process.nextTick(cb);\n    self.gateway.end();\n    self.queue.drain = drain;\n  };\n\n  // set things in motion\n  this.connected = false;\n  this.queue.pause();\n  return this;\n};\n\n/**\n * .setBadDevices ()\n *\n * If, after setting tokens here, message is sent to one\n * of these token, it'll result in error 8 \"Invalid token\".\n * Connection then will be closed.\n *\n * Intended to be used by clients when testing their error\n * mitigation logics.\n *\n * @param {Array} Array of Device\n * @name setBadDevices\n * @api public\n */\nMock.prototype.setBadDevices = function (devices) {\n  // Validate input, crash early if smth is wrong -\n  // better than search for a bug somewhere deep in code\n  if (!(devices instanceof Array)) {\n    throw new Error('Parameter \"devices\" should be an array of Device');\n  } else {\n    for (var i = 0; i < devices.length; i++) {\n      if (!(devices[i] instanceof Device)) {\n        throw new Error('Parameter \"devices\" should be an array of Device')\n      }\n    }\n  }\n\n  // All good\n  this.badDevices = devices;\n};\n\nMock.prototype._queueIterator = function (obj, next) {\n  var self = this\n    , cache = this.cache\n    , encoder = this.encoder\n    , stream = encoder.stream(obj.codec)\n    , id = obj.json.identifier\n    , queue = this.queue;\n\n  // wait for encoded message\n  encoder.once('readable', function () {\n    var buf = encoder.read()\n      , gateway = self.gateway;\n\n    // requeue if not connected\n    if (!gateway || !gateway.writable || !self.connected) {\n      debug('(queue) pause: not connected');\n      queue.pause();\n      queue.pushAt(0, obj);\n      return next();\n    }\n\n    debug('(gateway) write: %d', id);\n    gateway.write(buf);\n    process.nextTick(function () {\n      debug('(cache) push: %d', id);\n      cache.push(id, obj);\n      next();\n    });\n  });\n\n  // encode message\n  debug('(encoder) write: %d', id);\n  stream.write(obj.json);\n};\n","/home/travis/build/npmtest/node-npmtest-apnagent/node_modules/apnagent/lib/apnagent/feedback/live.js":"/*!\n * apnagent - Feedback (Live)\n * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar debug = require('sherlock')('apnagent:feedback-live')\n  , inherits = require('tea-inherits')\n  , ms = require('tea-ms')\n  , tls = require('tls');\n\n/*!\n * Internal dependancies\n */\n\nvar Base = require('./base')\n  , errors = require('../errors')\n  , util = require('../util');\n\n/*!\n * Primary Export\n */\n\nmodule.exports = Feedback;\n\n/**\n * Feedback (Live)\n *\n * A feedback connection will be opened on\n * on a schedule to check for devices that have\n * reported they are no longer capabable of\n * receiving push notifications.\n *\n * @api public\n */\n\nfunction Feedback () {\n  Base.call(this);\n}\n\ninherits(Feedback, Base);\n\nFeedback.prototype.connect = function (cb) {\n  cb = cb || function () {};\n\n  var self = this\n    , interval = this.get('interval')\n    , opts = util.feedbackOptions(this)\n    , feedback;\n\n  // don't try to connect without credentials\n  if (!opts.pfx && !opts.key && !opts.cert) {\n    process.nextTick(function () {\n      var err = new errors.FeedbackAuthorizationError('Insufficient credentials');\n      debug('(feedback) error: %s', err.message);\n      self.emit('feedback:error', err);\n      cb(err);\n    });\n\n    return this;\n  }\n\n  // how to perform a reconnect\n  function reconnect () {\n    debug('(feedback) reconnecting');\n    self.connect(function (err) {\n      if (err) return;\n      debug('(feedback) reconnected');\n      self.emit('feedback:reconnect');\n    });\n  }\n\n  // connect to feedback service\n  feedback = tls.connect(opts, function () {\n    if (feedback.authorized) {\n      debug('(feedback) connected - %s:%d', opts.host, opts.port);\n      self.connected = true;\n      self.emit('feedback:connect');\n      cb();\n    } else {\n      var err = new error.FeedbackAuthorizationError(gateway.authorizationError);\n      debug('(feedback) unauthorized - %s:%d', opts.host, opts.port, gateway.authorizationError);\n      self.feedback.destroy();\n      self.emit('gateway:error', err);\n      cb(err);\n    }\n  });\n\n  // handle a disconnection (expected)\n  feedback.on('close', function () {\n    self.feedback = null;\n\n    if (self.connected) {\n      debug('(feedback) disconnected - %s:%d', opts.host, opts.port);\n      self.connected = false;\n      self.meta.timer = setTimeout(reconnect, ms(interval));\n    } else {\n      debug('(feedback) closed - %s:%d', opts.host, opts.port);\n      self.connected = false;\n      self.emit('feedback:close');\n    }\n  });\n\n  // handle incoming data\n  feedback.on('data', function (buf) {\n    debug('(feedback) data: %d bytes', buf.length);\n    self.decoder.write(buf);\n  });\n\n  // emit errors;\n  feedback.on('error', function (err) {\n    debug('(feedback) error: %s', err.message || 'Unspecified Error');\n    self.emit('feedback:error', err);\n  });\n\n  // mount\n  this.feedback = feedback;\n  return this;\n};\n\nFeedback.prototype.close = function (cb) {\n  cb = cb || function () {};\n\n  // if not connected, cancel reconnect time\n  if (!this.connected || !this.feedback) {\n    clearTimeout(this.meta.timer);\n    process.nextTick(cb);\n    return this;\n  }\n\n  // wait for feedback to finish download\n  this.feedback.once('end', cb);\n  this.connected = false;\n  return this;\n};\n","/home/travis/build/npmtest/node-npmtest-apnagent/node_modules/apnagent/lib/apnagent/feedback/base.js":"/*!\n * apnagent - Feedback (Base)\n * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar debug = require('sherlock')('apnagent:feedback-base')\n  , EventEmitter = require('drip').EnhancedEmitter\n  , facet = require('facet')\n  , inherits = require('tea-inherits')\n  , lotus = require('lotus')\n  , Queue = require('breeze-queue')\n  , series = require('breeze-async').forEachSeries;\n\n/*!\n * Internal dependancies\n */\n\nvar codecs = require('../codecs')\n  , Device = require('../device')\n  , errors = require('../errors');\n\n/*!\n * Primary Export\n */\n\nmodule.exports = Base;\n\n/**\n * ## Feedback API\n *\n * This is the feedback api.\n *\n * @header Feedback API\n * @see #header-feedback Feedback Guide\n */\n\nfunction Base () {\n  EventEmitter.call(this, { delimeter: ':' });\n  this.connected = false;\n  this.set('interval', '30m');\n  this.disable('sandbox');\n\n  this.meta = {};\n  this.meta.timer = null;\n  this.meta.stack = [ emit ];\n\n  var self = this\n    , decoder, queue;\n\n  // queue handles user interaction with responses\n  queue = new Queue(function (obj, done) {\n    var device = obj.device\n      , stack = self.meta.stack\n      , timestamp = obj.timestamp;\n\n    // intercept errors so as not to cancel queue\n    function finish (err) {\n      if (err) {\n        debug('(iterate) error - %s', err.message);\n        self.emit('iterate:error', err, device, timestamp);\n      }\n\n      debug('(iterate) end - %s', device.toString());\n      done();\n    }\n\n    // start iteration\n    debug('(iterate) start - %s', device.toString());\n    series(stack, function (fn, next) {\n      fn.apply(self, [ device, timestamp, next ]);\n    }, finish);\n  }, 10);\n\n  // emit queue errors on feedback agent\n  queue.onerror = function (err) {\n    debug('(queue) error: %s', err.message);\n    self.emit('queue:error', err);\n  };\n\n  // emit queue drain on feedback agent\n  queue.drain = function () {\n    debug('(queue) drain');\n    self.emit('queue:drain');\n  };\n\n  // decoder handing incoming feedback responses\n  decoder = lotus.createDecoder();\n  decoder.stream(codecs.getInterface('feedback response', 'decode'));\n  decoder.stream().on('readable', function () {\n    var obj = this.read()\n      , res = {};\n    res.device = new Device(obj.deviceToken);\n    res.timestamp = new Date(obj.timestamp * 1000);\n    queue.push(res, true);\n  });\n\n  this.decoder = decoder;\n  this.feedback = null;\n  this.queue = queue;\n}\n\n/*!\n * Inherits from EnhancedEmitter\n */\n\ninherits(Base, EventEmitter);\n\n/*!\n * Mount facet helpers\n */\n\nfacet(Base.prototype, function (key, value) {\n  key = key.toLowerCase();\n\n  // handle queue concurrency change\n  if (key === 'concurrency') {\n    if ('number' !== typeof value) {\n      throw new Error('.set(\\'concurrency\\') fail: value must be a number');\n    }\n\n    if (value <= 0) {\n      throw new Error('.set(\\'concurrency\\') fail: value must be greater than zero');\n    }\n\n    this.queue._concurrency = value;\n  }\n});\n\nObject.defineProperty(Base.prototype, 'length', {\n  get: function () {\n    return this.queue.length;\n  }\n});\n\n/**\n * ### .use (fn)\n *\n * @param {Function} fn to add to stack\n * @name use\n * @api public\n */\n\nBase.prototype.use = function (fn) {\n  this.meta.stack.push(fn);\n  return this;\n};\n\nBase.prototype.unsub = function () {};\n\n/**\n * ### .connect ([ callback ])\n *\n *\n * @param {Function} callback\n * @return {this} for chaining\n * @name connect\n * @api public\n */\n\nBase.prototype.connect = function () {\n  throw new Error('Feedback connect not implemented.');\n};\n\n/**\n * ### .close ([ callback ])\n *\n * Close the active gateway connection or cancel\n * further reconnect attempts. If the queue is currently\n * processing a message it will wait for the current\n * message to finish before closing.\n *\n * Apple recommends that a connection always remains open\n * even when there are no messages to process. Production\n * deployments should use this sparingly.\n *\n * @param {Function} callback\n * @return {this} for chaining\n * @name close\n * @api public\n */\n\nBase.prototype.close = function () {\n  throw new Error('Feedback close not implemented.');\n};\n\nfunction emit (device, timestamp, next) {\n  debug('(feedback) device - %s', device.toString());\n  this.emit('device', device, timestamp);\n  next();\n}\n","/home/travis/build/npmtest/node-npmtest-apnagent/node_modules/apnagent/lib/apnagent/feedback/mock.js":"\n\nvar debug = require('sherlock')('apnagent:feedbock-mock')\n  , inherits = require('tea-inherits')\n  , ms = require('tea-ms')\n  , lotus = require('lotus');\n\nvar Base = require('./base')\n  , codecs = require('../codecs')\n  , Device = require('../device')\n  , errors = require('../errors')\n  , util = require('../util');\n\nmodule.exports = Mock;\n\nfunction Mock () {\n  Base.call(this);\n  this.meta.outgoing = [];\n}\n\ninherits(Mock, Base);\n\nMock.prototype.connect = function (cb) {\n  cb = cb || function () {};\n\n  var self = this\n    , interval = this.get('interval')\n    , opts = util.feedbackOptions(this)\n    , feedback;\n\n  // how to perform a reconnect\n  function reconnect () {\n    debug('(feedback) reconnecting');\n    self.connect(function (err) {\n      if (err) return;\n      debug('(feedback) reconnected');\n      self.emit('feedback:reconnect');\n    });\n  }\n\n  // mock feedback writes mock unsubs to decoder\n  feedback = lotus.createEncoder();\n  feedback.stream(codecs.getInterface('feedback response', 'encode'));\n\n  // simulate async connect\n  debug('(feedback) connecting - mock');\n  process.nextTick(function () {\n    debug('(feedback) connected - mock');\n    self.connected = true;\n    self.emit('feedback:connect');\n    cb();\n\n    // send simulated data\n    setTimeout(function () {\n      var outgoing = self.meta.outgoing\n        , stream = feedback.stream()\n        , line;\n\n      debug('(mock) simulating [%d] unsubs', outgoing.length);\n      while (outgoing.length) {\n        line = outgoing.shift();\n        debug('(mock) writing unsub - %s', line.deviceToken.toString('hex'));\n        stream.write(line);\n      }\n\n      debug('(mock) writing complete');\n      stream.end();\n    }, 10);\n  });\n\n  // handle \"incoming\" data\n  feedback.on('data', function (buf) {\n    debug('(feedback) data: %d bytes, buf.length');\n    self.decoder.write(buf);\n  });\n\n  // emit errors;\n  feedback.on('error', function (err) {\n    debug('(feedback) error: %s', err.message || 'Unspecified Error');\n    self.emit('feedback:error', err);\n  });\n\n  // end is similiar to a socket `close` event\n  feedback.on('end', function () {\n    self.feedback = null;\n\n    if (self.connected) {\n      debug('(feedback) disconnected - %s:%d', opts.host, opts.port);\n      self.connected = false;\n      self.meta.timer = setTimeout(reconnect, ms(interval));\n    } else {\n      debug('(feedback) closed - %s:%d', opts.host, opts.port);\n      self.connected = false;\n      self.emit('feedback:close');\n    }\n  });\n\n  // mount\n  this.feedback = feedback;\n  return this;\n};\n\n\nMock.prototype.unsub = function (token, ts) {\n  var device = new Device(token)\n    , timestamp;\n\n  // figure out time\n  if (ts && 'number' === typeof ts) {\n    timestamp = ts;\n  } else if (ts && 'string' === typeof ts) {\n    timestamp = ms.unix(ts);\n  } else if (ts && ts instanceof Date) {\n    timestamp = ts.getTime() / 1000;\n  } else {\n    timestamp = ms.unix('-1s');\n  }\n\n  // add to outgoing queue\n  this.meta.outgoing.push({\n      deviceToken: device.toBuffer()\n    , timestamp: timestamp\n  });\n\n  return this;\n};\n\nMock.prototype.close = function (cb) {\n  cb = cb || function () {};\n\n  // if not connected, cancel reconnect time\n  if (!this.connected || !this.feedback) {\n    clearTimeout(this.meta.timer);\n    process.nextTick(cb);\n    return this;\n  }\n\n  // wait for feedback to finish download\n  this.feedback.once('end', cb);\n  this.connected = false;\n  return this;\n};\n"}